/**
 * Created by idoco on 29/1/2016.
 * buttons logic
 */

var Github = require("github-api");
var request = require('superagent');

var Entry = require("./Entry");

function Controller() {

    var github, mainRepo, forkedRepo,
        authToken, username, entry, onPullRequestReady,
        retries = 10;

    function refreshMap() {
        var iFrame = document.getElementById("mapFrame");
        //noinspection SillyAssignmentJS
        iFrame.src = iFrame.src;
    }

    function postNewEntry(data) {
        if (authToken) {
            startGitHubFlow(data);
        } else {
            acquireAuthToken(data);
        }
    }

    function isTokenReady() {
        return authToken;
    }

    function isUrlWithCode() {
        return window.location.href.indexOf('?code') >= 0;
    }

    function acquireAuthToken(data) {
        var queryString = window.location.href.slice(window.location.href.indexOf('?code') + 1).split('=');
        authToken = queryString[1];
        window.history.replaceState({}, 'GitMap', window.location.href.slice(0, window.location.href.indexOf('?')));

        // the cake is a lie
        // I can eliminate this call by exposing the client_secret in the web_client, I wonder if that would be ok
        request.get('https://hook.io/idoco/github-doorman?code=' + authToken)
            .end(function (err, res) {
                if (err) return reportError(err);
                if (res.body.token === '') return reportError("One-time token already used");

                github = new Github({
                    token: res.body.token,
                    auth: "oauth"
                });

                github.getUser().show(null, function (err, user) {
                    if (err) return reportError(err);
                    username = user.login;
                    startGitHubFlow(data);
                });
            });
    }

    function startGitHubFlow(data) {
        entry = data.entry;
        onPullRequestReady = data.callback;

        try {
            Entry.validateEntry(entry);
        } catch (e) {
            return reportError(e);
        }

        mainRepo = github.getRepo("idoco", "GitMap");
        mainRepo.fork(function (err) {
            if (err) return reportError(err);
            pollForFork();
        });
    }

    // loop 10 times to validate that the fork operation ended successfully
    function pollForFork() {
        forkedRepo = github.getRepo(username, "GitMap");

        forkedRepo.contents('gh-pages', "map.geojson",
            function (err) {
                if (err && retries) {
                    console.error(err);
                    retries--;
                    setTimeout(pollForFork, 100);
                } else if (err) {
                    return reportError(err);
                } else {
                    readMapFile();
                }
            }
        );
    }

    function readMapFile() {
        mainRepo.read('gh-pages', 'map.geojson',
            function (err, geojson) {
                if (err) return reportError(err);
                editMapFile(geojson);
            }
        );
    }

    function editMapFile(geojson) {

        // pushing the new entry in a random index in the list should make automatic merging simpler
        var features = geojson.features;
        var randomIndexInFeaturesArray = Math.floor(Math.random() * (features.length-1));
        entry.properties.contact = "<a href=https://github.com/"+username+"/>"+username+"</a>";
        features.splice(randomIndexInFeaturesArray, 0, entry);

        var options = {
            committer: {name: username, email: username + '@unknown.com'},
            encode: true // Whether to base64 encode the file. (default: true)
        };

        var jsonString = JSON.stringify(geojson, null, 4);
        forkedRepo.write('gh-pages', 'map.geojson', jsonString, 'Adding entry to map', options,
            function (err) {
                if (err) return reportError(err);
                createPullRequest();
            }
        );
    }

    function createPullRequest() {
        var pull = {
            title:  "New entries by " + username,
            body:   "This pull request has been automatically generated by Github.js",
            base:   "gh-pages",
            head:   username + ":" + "gh-pages"
        };

        mainRepo.createPullRequest(pull,
            function (err, pullRequest) {
                if (err) return reportError(err);
                onPullRequestReady({pullRequestUrl: pullRequest.html_url});
            }
        );
    }

    function reportError(err){
        console.error(err);
        if (err && err.request && err.request.responseText){
            try {
                var responseText = JSON.parse(err.request.responseText);
                if (responseText.errors && responseText.errors[0] && responseText.errors[0].message) {
                    onPullRequestReady({err: "" +  responseText.errors[0].message});
                } else {
                    onPullRequestReady({err: "" +  responseText.message});
                }
            } catch (e) {
                onPullRequestReady({err: "" + err.request.responseText});
            }
        } else {
            onPullRequestReady({err: ""+err});
        }
    }

    return {
        refreshMap: refreshMap,
        postNewEntry: postNewEntry,
        isTokenReady: isTokenReady,
        isUrlWithCode: isUrlWithCode
    };
}

module.exports = Controller;

